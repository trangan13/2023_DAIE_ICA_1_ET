## Clear console on each execute

```{r echo=TRUE}
# Clear console on each execute 
cat('\014')
```

```{r echo=FALSE}
# Set a CRAN mirror for package installation, this was done as I was getting an error for unknown mirror. 

options(repos = c(CRAN = "https://cloud.r-project.org"))

```

## Download and load libraries

```{r echo=TRUE, message=FALSE, warning=FALSE}
if(!require("DBI")) install.packages("DBI") 
if(!require("dplyr")) install.packages("dplyr") 
if(!require("tidyverse")) install.packages("tidyverse")
if(!require("RSQLite")) install.packages("RSQLite")

library(DBI) 
library(dplyr) 
library(tidyverse)
library(RSQLite)
```

## Connect to the provided SQLite Database

```{r echo=TRUE}
conn <- dbConnect(RSQLite::SQLite(), "ICA_2023.sqlite")
```

# Part A: Introduction

In the first part of the assestment, we will write basic SQL queries to extract meaningful insights from a database related to game development projects. To start with this process, I have gained some general context by viewing the tables which has helped in understanding their relationship to begin crafting the queries.

# Core Queries

## Query 1: Total Budget and Project Count per Country

```{r echo=FALSE}

# SQL query 
query <- "
SELECT 
  c.CustomerCountry, 
  SUM(p.Budget) AS TotalBudget, 
  COUNT(p.ProjectID) AS ProjectCount
FROM 
  Projects p
JOIN 
  Customers c ON p.CustomerID = c.CustomerID
GROUP BY 
  c.CustomerCountry
ORDER BY 
  TotalBudget DESC;
"

# Executing the query and assigning results to variable
result <- dbGetQuery(conn, query)

knitr::kable(result)

```

## Query 2: Average project development time by number of assets

```{r echo=FALSE}

# SQL query, adding a subquery as groupby was not accepting AVG
query <- "
SELECT 
  AssetCount.NumberOfAssets, 
  AVG(julianday(p.EndDate) - julianday(p.StartDate)) AS AverageDevelopmentTime
FROM 
  Projects p
INNER JOIN 
  (SELECT 
     ProjectID, 
     COUNT(*) AS NumberOfAssets 
   FROM 
     Assets 
   GROUP BY 
     ProjectID) AS AssetCount ON p.ProjectID = AssetCount.ProjectID
GROUP BY 
  AssetCount.NumberOfAssets
ORDER BY 
  AssetCount.NumberOfAssets DESC;
  "

# Executing the query and assigning results to variable
result <- dbGetQuery(conn, query)

knitr::kable(result)
```

## Query 3: Top three developers based on successful project count

```{r echo=FALSE}

# SQL query 
query <- "
SELECT 
  d.Name, 
  COUNT(pd.ProjectID) AS SuccessfulProjects
FROM 
  Developers d
JOIN 
  ProjectDevelopers pd ON d.DeveloperID = pd.DeveloperID
JOIN 
  Projects p ON pd.ProjectID = p.ProjectID
WHERE 
  p.Status = 'Completed'
GROUP BY 
  d.DeveloperID
ORDER BY 
  SuccessfulProjects DESC
LIMIT 3;
"

# Executing the query and assigning results to variable
result <- dbGetQuery(conn, query)

knitr::kable(result)
```

# SQL Concepts Demonstration

### **1. SELECT with LIKE and OR: Find developers with specialization as Programmer or Writer.**

```{r echo=FALSE}

# SQL query 
query <- "
SELECT *
FROM Developers
WHERE Specialization LIKE '%Programmer%' OR Specialization LIKE '%Writer%';

"

# Executing the query and assigning results to variable
result <- dbGetQuery(conn, query)

knitr::kable(result)


```

### **2. SELECT with DISTINCT and ORDER BY: List of distinct asset types ordered alphabetically.**

```{r echo=FALSE}

# SQL query  
query <- " 
SELECT DISTINCT Type
FROM Assets
ORDER BY Type;
 "  

# Executing the query and assigning results to variable 
result <- dbGetQuery(conn, query)  
knitr::kable(result)  
```

### **3. Subquery with SELECT: Filter projects with above average budgets**

```{r echo=FALSE}
# SQL query   
query <- "  
SELECT *
FROM Projects
WHERE Budget > (SELECT AVG(Budget) FROM Projects);
"    


# Executing the query and assigning results to variable  
result <- dbGetQuery(conn, query)   
knitr::kable(result)  
```

# Part B: Linear Regression

In this part of the assessments, I will utilize the same datasets to apply a linear regression analysis that will provide some trends and patterns in the game development lifecycle. The assestment specifies to perform linear regression to predict the success rate of a project based on its budget and team size.

## Model

```{r echo=FALSE}
# To be able to perform the request, I first need to stablish what succesful looks like and how to account for a team size as there are no columns with either data. I will define completion as success and team sized based on number of developers assigned to a project. 

# SQL query 
query <- " 
SELECT 
  p.ProjectID, 
  p.Budget,
  CASE 
    WHEN p.Status = 'Completed' THEN 1 
    ELSE 0 
  END AS Success,
  COUNT(DISTINCT ad.DeveloperID) AS TeamSize
FROM 
  Projects p
JOIN 
  Assets a ON p.ProjectID = a.ProjectID
JOIN
  AssetsDevelopers ad ON a.AssetID = ad.AssetID
GROUP BY 
  p.ProjectID, p.Budget, p.Status;
"

dataset <- dbGetQuery(conn, query)

# model <- lm(Success ~ Budget + TeamSize, data = dataset)

knitr::kable(dataset)  
```

## Interpret

## Discuss

# Disconnect from the database

```{r}
dbDisconnect(conn)
```
