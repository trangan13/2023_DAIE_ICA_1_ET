## Clear console on each execute

```{r echo=TRUE}
# Clear console on each execute 
cat('\014')
```

```{r echo=FALSE}
# Set a CRAN mirror for package installation, this was done as I was getting an error for unknown mirror. 

options(repos = c(CRAN = "https://cloud.r-project.org"))

```

## Download and load libraries

```{r echo=TRUE, message=FALSE, warning=FALSE}
if(!require("DBI")) install.packages("DBI") 
if(!require("dplyr")) install.packages("dplyr") 
if(!require("tidyverse")) install.packages("tidyverse")
if(!require("RSQLite")) install.packages("RSQLite")
if(!require("scales")) install.packages("scales")


library(DBI) 
library(dplyr) 
library(tidyverse)
library(RSQLite)
library(ggplot2)
library(scales)
```

## Connect to the provided SQLite Database

```{r echo=TRUE}
conn <- dbConnect(RSQLite::SQLite(), "ICA_2023.sqlite")
```

# Part A: Introduction

In the first part of the assestment, we will write basic SQL queries to extract meaningful insights from a database related to game development projects. To start with this process, I have gained some general context by viewing the tables which has helped in understanding their relationship to begin crafting the queries.

# Core Queries

## Query 1: Total Budget and Project Count per Country

```{r echo=FALSE}

# SQL query 
query <- "
SELECT 
  c.CustomerCountry, 
  SUM(p.Budget) AS TotalBudget, 
  COUNT(p.ProjectID) AS ProjectCount
FROM 
  Projects p
JOIN 
  Customers c ON p.CustomerID = c.CustomerID
GROUP BY 
  c.CustomerCountry
ORDER BY 
  TotalBudget DESC;
"

# Executing the query and assigning results to variable
result <- dbGetQuery(conn, query)

knitr::kable(result)

```

## Query 2: Average project development time by number of assets

```{r echo=FALSE}

# SQL query, adding a subquery as groupby was not accepting AVG
query <- "
SELECT 
  AssetCount.NumberOfAssets, 
  AVG(julianday(p.EndDate) - julianday(p.StartDate)) AS AverageDevelopmentTime
FROM 
  Projects p
INNER JOIN 
  (SELECT 
     ProjectID, 
     COUNT(*) AS NumberOfAssets 
   FROM 
     Assets 
   GROUP BY 
     ProjectID) AS AssetCount ON p.ProjectID = AssetCount.ProjectID
GROUP BY 
  AssetCount.NumberOfAssets
ORDER BY 
  AssetCount.NumberOfAssets DESC;
  "

# Executing the query and assigning results to variable
result <- dbGetQuery(conn, query)

knitr::kable(result)
```

## Query 3: Top three developers based on successful project count

```{r echo=FALSE}

# SQL query 
query <- "
SELECT 
  d.Name, 
  COUNT(pd.ProjectID) AS SuccessfulProjects
FROM 
  Developers d
JOIN 
  ProjectDevelopers pd ON d.DeveloperID = pd.DeveloperID
JOIN 
  Projects p ON pd.ProjectID = p.ProjectID
WHERE 
  p.Status = 'Completed'
GROUP BY 
  d.DeveloperID
ORDER BY 
  SuccessfulProjects DESC
LIMIT 3;
"

# Executing the query and assigning results to variable
result <- dbGetQuery(conn, query)

knitr::kable(result)
```

# SQL Concepts Demonstration

### **1. SELECT with LIKE and OR: Find developers with specialization as Programmer or Writer.**

```{r echo=FALSE}

# SQL query 
query <- "
SELECT *
FROM Developers
WHERE Specialization LIKE '%Programmer%' OR Specialization LIKE '%Writer%';

"

# Executing the query and assigning results to variable
result <- dbGetQuery(conn, query)

knitr::kable(result)


```

### **2. SELECT with DISTINCT and ORDER BY: List of distinct asset types ordered alphabetically.**

```{r echo=FALSE}

# SQL query  
query <- " 
SELECT DISTINCT Type
FROM Assets
ORDER BY Type;
 "  

# Executing the query and assigning results to variable 
result <- dbGetQuery(conn, query)  
knitr::kable(result)  
```

### **3. Subquery with SELECT: Filter projects with above average budgets**

```{r echo=FALSE}
# SQL query   
query <- "  
SELECT *
FROM Projects
WHERE Budget > (SELECT AVG(Budget) FROM Projects);
"    


# Executing the query and assigning results to variable  
result <- dbGetQuery(conn, query)   
knitr::kable(result)  
```

# Part B: Linear Regression

In this part of the assessments, I will utilize the same datasets to apply a linear regression analysis that will provide some trends and patterns in the game development lifecycle. The assestment specifies to perform linear regression to predict the success rate of a project based on its budget and team size.

## Table

```{r echo=FALSE}
# To be able to perform the request, I first need to stablish what succesful looks like and how to account for a team size as there are no columns with either data. I will define completion as success and team sized based on number of developers assigned to a project. 

# SQL query / The query was missing counting developers from the ProjectDeveloper table, as all projects have at least one developer. I am adding that developer but making sure it does not repeat from within the Assets table. 
query <- " 
SELECT 
  p.ProjectID, 
  p.Budget,
  CASE 
    WHEN p.Status = 'Completed' THEN 1 
    ELSE 0 
  END AS Success,
  COUNT(DISTINCT combined_devs.DeveloperID) AS TeamSize
FROM 
  Projects p
LEFT JOIN  
  (
  SELECT pd.ProjectID, pd.DeveloperID 
  FROM ProjectDevelopers pd
  UNION
  SELECT a.ProjectID, ad.DeveloperID 
  FROM Assets a
JOIN
  AssetsDevelopers ad ON a.AssetID = ad.AssetID) AS combined_devs
  ON p.ProjectID = combined_devs.ProjectID
GROUP BY 
  p.ProjectID;
"

dataset <- dbGetQuery(conn, query)
knitr::kable(dataset) 


```

### Linear Regression model

```{r echo=FALSE}

# Now that the table is showing the data expected I am going to run linear regression and plot it. 

model <- lm(Success ~ Budget + TeamSize, data = dataset)
summary(model)
```

### Scatter Plot: Success vs. Budget

```{r echo=FALSE}
# Using the scales package in order to show budget data more clearly. 

ggplot(dataset, aes(x = Budget, y = Success)) +
  geom_point() +
  geom_smooth(method = "lm", color = "green") +
  labs(title = "Success vs. Budget", x = "Budget",y = "Success Rate") +
  scale_x_continuous(labels = label_number()) +
  theme_minimal()

```

### Scatter Plot: Success vs. Team Size

```{r echo=FALSE}
# Using the scales package in order to show full integers in team size from 1 till 9. 

ggplot(dataset, aes(x = TeamSize, y = Success)) +
  geom_point() +
  geom_smooth(method = "lm", color = "red") +
  labs(title = "Success vs. Team Size", x = "Team Size", y = "Success Rate") +
  scale_x_continuous(breaks = c(1,2,3,4,5,6,7,8,9,10)) +
  theme_minimal()

```

## Interpretation

```{r echo=FALSE}
```

## Discussion

# Disconnect from the database

```{r}
dbDisconnect(conn)
```
